
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸš€ Generated by GitMaxer (Free Plan)
# ğŸ”— Upgrade at https://gitmaxer.vercel.app for watermark-free code
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// /**
//  * Educational Tutorial: Exploring Recursion and Graphical Rendering with a Mandelbrot Fractal Viewer in Java
//  *
//  * Learning Objective:
//  * This tutorial aims to teach beginners the fundamental concepts of recursion
//  * and how it can be applied to graphical rendering. We will create a simple
//  * Mandelbrot fractal viewer to demonstrate these concepts. You will learn:
//  * 1. What recursion is and how it works.
//  * 2. How to implement a recursive function.
//  * 3. Basic graphical rendering in Java using `java.awt.Graphics`.
//  * 4. How to map mathematical concepts to visual output.
//  */
//
// import javax.swing.*;
// import java.awt.*;
// import java.awt.image.BufferedImage;
//
// public class MandelbrotViewer extends JFrame {
//
//     // The width and height of our fractal image.
//     private static final int WIDTH = 600;
//     private static final int HEIGHT = 600;
//
//     // The BufferedImage will store our fractal's pixels.
//     private BufferedImage fractalImage;
//
//     // Constructor: Sets up the window and initializes the fractal.
//     public MandelbrotViewer() {
//         setTitle("Mandelbrot Fractal Viewer");
//         setSize(WIDTH, HEIGHT);
//         setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
//         setLocationRelativeTo(null); // Center the window
//
//         // Initialize the image buffer that we'll draw onto.
//         fractalImage = new BufferedImage(WIDTH, HEIGHT, BufferedImage.TYPE_INT_RGB);
//
//         // Start the process of generating and drawing the fractal.
//         generateMandelbrot();
//     }
//
//     // This method orchestrates the fractal generation.
//     private void generateMandelbrot() {
//         // We iterate over each pixel in our image.
//         for (int x = 0; x < WIDTH; x++) {
//             for (int y = 0; y < HEIGHT; y++) {
//                 // Map pixel coordinates to the complex plane.
//                 // The Mandelbrot set is defined on complex numbers.
//                 // We're scaling our screen coordinates (0 to WIDTH/HEIGHT)
//                 // to a relevant range in the complex plane (-2.0 to 1.0 for real, -1.5 to 1.5 for imaginary).
//                 double real = (double) x / WIDTH * 3.0 - 2.0;
//                 double imaginary = (double) y / HEIGHT * 3.0 - 1.5;
//
//                 // This is where the core logic happens:
//                 // We call our recursive function to determine if this point
//                 // is part of the Mandelbrot set and how quickly it escapes.
//                 int iterations = mandelbrotRecursive(real, imaginary, 0);
//
//                 // Color the pixel based on the number of iterations.
//                 // If 'iterations' reaches the maximum (defined by MAX_ITERATIONS),
//                 // the point is likely in the set (black). Otherwise, it's outside.
//                 Color pixelColor = getColor(iterations);
//                 fractalImage.setRGB(x, y, pixelColor.getRGB());
//             }
//         }
//     }
//
//     // Maximum number of iterations to check for escape.
//     // This controls the detail and complexity of the fractal.
//     private static final int MAX_ITERATIONS = 50;
//
//     // RECURSION DEMONSTRATION:
//     // This function calculates how many iterations it takes for a complex number
//     // `c` (represented by `real` and `imaginary`) to escape a certain boundary.
//     // It uses recursion to repeatedly apply the Mandelbrot formula: z = z^2 + c.
//     //
//     // - `currentReal` and `currentImaginary`: The current value of 'z' in the iteration.
//     // - `iterationCount`: The number of times we've applied the formula so far.
//     private int mandelbrotRecursive(double real, double imaginary, int iterationCount) {
//         // BASE CASE: If the point escapes or we reach the maximum iterations, stop recursing.
//         // A point escapes if its magnitude squared exceeds 4.0.
//         if (currentReal * currentReal + currentImaginary * currentImaginary > 4.0 || iterationCount >= MAX_ITERATIONS) {
//             return iterationCount; // Return the number of iterations taken.
//         }
//
//         // RECURSIVE STEP:
//         // Apply the Mandelbrot formula: z_next = z_current^2 + c
//         // z = a + bi
//         // z^2 = (a + bi)^2 = a^2 + 2abi + (bi)^2 = a^2 + 2abi - b^2 = (a^2 - b^2) + (2ab)i
//         // So, the new real part is (currentReal^2 - currentImaginary^2) + initialReal(c)
//         // And the new imaginary part is (2 * currentReal * currentImaginary) + initialImaginary(c)
//
//         // Calculate the next values for 'z'.
//         double nextReal = currentReal * currentReal - currentImaginary * currentImaginary + real;
//         double nextImaginary = 2 * currentReal * currentImaginary + imaginary;
//
//         // Make the recursive call with the new 'z' values and an incremented iteration count.
//         return mandelbrotRecursive(nextReal, nextImaginary, iterationCount + 1);
//     }
//
//     // Helper function to convert iteration count to a color.
//     private Color getColor(int iterations) {
//         if (iterations == MAX_ITERATIONS) {
//             return Color.BLACK; // Points inside the set are black.
//         } else {
//             // Points outside the set are colored based on how quickly they escaped.
//             // This creates the colorful patterns. We can use a simple gradient.
//             float hue = (float) iterations / MAX_ITERATIONS;
//             float saturation = 1.0f;
//             float brightness = 1.0f;
//             return Color.getHSBColor(hue, saturation, brightness);
//         }
//     }
//
//     // This method is called by Swing to paint the component.
//     @Override
//     public void paintComponent(Graphics g) {
//         super.paintComponent(g);
//         // Draw our generated fractal image onto the screen.
//         g.drawImage(fractalImage, 0, 0, this);
//     }
//
//     // Main method to run the application.
//     public static void main(String[] args) {
//         // Use SwingUtilities.invokeLater to ensure GUI updates happen on the Event Dispatch Thread (EDT).
//         // This is a best practice for Swing applications.
//         SwingUtilities.invokeLater(() -> {
//             MandelbrotViewer viewer = new MandelbrotViewer();
//             viewer.setVisible(true); // Make the window visible.
//         });
//     }
// }
//
// Example Usage:
// To run this code:
// 1. Save it as "MandelbrotViewer.java".
// 2. Compile it using a Java Development Kit (JDK):
//    javac MandelbrotViewer.java
// 3. Run the compiled code:
//    java MandelbrotViewer
//
// A window will appear displaying the Mandelbrot fractal.
//
// Key Concepts Covered:
// - Recursion: The mandelbrotRecursive function calls itself.
//   - Base Case: The condition(s) under which the recursion stops.
//   - Recursive Step: The part where the function calls itself with modified arguments.
// - Graphical Rendering: Using BufferedImage and Graphics to draw pixels.
// - Mapping: Converting screen coordinates to complex numbers.
// - Iteration: Repeating a process to achieve a result.
//
// For further exploration, you could:
// - Add zoom functionality.
// - Experiment with different color mapping schemes.
// - Modify MAX_ITERATIONS for higher detail.
// - Implement the Mandelbrot calculation iteratively instead of recursively to compare performance and memory usage.

// ** IMPORTANT NOTE FOR THE TUTORIAL COMMENTARY ABOVE: **
// I have commented out the actual code and placed the explanation within the comments.
// The prompt specifically asked for NO markdown formatting and JUST raw code with comments.
// To make this a functional tutorial, you would uncomment the code blocks.
// The structure above is designed to present the explanation FIRST, then the code,
// which is a common educational approach, but for this prompt, it's presented as
// commented-out code with explanations.
//
// To make this runnable and as requested, the actual Java code must be uncommented.
// I will now provide the uncommented, runnable code with the explanatory comments.

// /**
//  * Educational Tutorial: Exploring Recursion and Graphical Rendering with a Mandelbrot Fractal Viewer in Java
//  *
//  * Learning Objective:
//  * This tutorial aims to teach beginners the fundamental concepts of recursion
//  * and how it can be applied to graphical rendering. We will create a simple
//  * Mandelbrot fractal viewer to demonstrate these concepts. You will learn:
//  * 1. What recursion is and how it works.
//  * 2. How to implement a recursive function.
//  * 3. Basic graphical rendering in Java using `java.awt.Graphics`.
//  * 4. How to map mathematical concepts to visual output.
//  */

import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;

public class MandelbrotViewer extends JFrame {

    // The width and height of our fractal image.
    private static final int WIDTH = 600;
    private static final int HEIGHT = 600;

    // The BufferedImage will store our fractal's pixels.
    private BufferedImage fractalImage;

    // The current real and imaginary parts of 'z' during the recursive calculation.
    // These are made instance variables to be accessible by the recursive method.
    private double currentReal;
    private double currentImaginary;

    // Constructor: Sets up the window and initializes the fractal.
    public MandelbrotViewer() {
        setTitle("Mandelbrot Fractal Viewer");
        setSize(WIDTH, HEIGHT);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLocationRelativeTo(null); // Center the window

        // Initialize the image buffer that we'll draw onto.
        // TYPE_INT_RGB is a common format for storing color pixels.
        fractalImage = new BufferedImage(WIDTH, HEIGHT, BufferedImage.TYPE_INT_RGB);

        // Start the process of generating and drawing the fractal.
        generateMandelbrot();
    }

    // This method orchestrates the fractal generation.
    // It iterates over every pixel on our screen.
    private void generateMandelbrot() {
        // We iterate over each pixel in our image.
        for (int x = 0; x < WIDTH; x++) {
            for (int y = 0; y < HEIGHT; y++) {
                // Map pixel coordinates to the complex plane.
                // The Mandelbrot set is defined on complex numbers (c = real + i * imaginary).
                // We're scaling our screen coordinates (0 to WIDTH/HEIGHT)
                // to a relevant range in the complex plane.
                // Commonly used range for the Mandelbrot set is:
                // Real part: -2.0 to 1.0
                // Imaginary part: -1.5 to 1.5
                double real = (double) x / WIDTH * 3.0 - 2.0;
                double imaginary = (double) y / HEIGHT * 3.0 - 1.5;

                // Reset the initial 'z' for each new point 'c'.
                // The Mandelbrot iteration starts with z = 0.
                this.currentReal = 0.0;
                this.currentImaginary = 0.0;

                // This is where the core logic happens:
                // We call our recursive function to determine if this point 'c'
                // is part of the Mandelbrot set and how quickly it "escapes" a boundary.
                int iterations = mandelbrotRecursive(real, imaginary, 0);

                // Color the pixel based on the number of iterations.
                // If 'iterations' reaches the maximum (defined by MAX_ITERATIONS),
                // the point is considered to be *in* the set (colored black).
                // Otherwise, it's outside the set, and its color indicates
                // how quickly it escaped.
                Color pixelColor = getColor(iterations);
                fractalImage.setRGB(x, y, pixelColor.getRGB());
            }
        }
    }

    // Maximum number of iterations to check for escape.
    // This controls the detail and complexity of the fractal.
    // A higher number means more detailed fractals but takes longer to compute.
    private static final int MAX_ITERATIONS = 50;

    // RECURSION DEMONSTRATION:
    // This function calculates how many iterations it takes for a complex number
    // `c` (represented by `real` and `imaginary`) to escape a certain boundary.
    // It uses recursion to repeatedly apply the Mandelbrot formula: z = z^2 + c.
    //
    // Parameters:
    // - `initialReal`: The real part of the constant 'c' for this point.
    // - `initialImaginary`: The imaginary part of the constant 'c' for this point.
    // - `iterationCount`: The number of times we've applied the formula so far.
    //
    // Returns: The total number of iterations performed before escaping or reaching MAX_ITERATIONS.
    private int mandelbrotRecursive(double initialReal, double initialImaginary, int iterationCount) {
        // BASE CASE: This is the condition that stops the recursion.
        // We stop if the magnitude of 'z' squared is greater than 4.0 (meaning it will escape to infinity),
        // OR if we have reached our maximum allowed iterations.
        // The condition `currentReal * currentReal + currentImaginary * currentImaginary > 4.0` is an optimization.
        // It's equivalent to checking if `abs(z) > 2.0` but avoids the expensive square root operation.
        if (currentReal * currentReal + currentImaginary * currentImaginary > 4.0 || iterationCount >= MAX_ITERATIONS) {
            return iterationCount; // Return the number of iterations taken.
        }

        // RECURSIVE STEP:
        // This is where the function calls itself. We need to calculate the next value of 'z'
        // using the Mandelbrot formula: z_next = z_current^2 + c.
        //
        // Let z = a + bi (where 'a' is currentReal, 'b' is currentImaginary)
        // and c = initialReal + i * initialImaginary.
        //
        // z^2 = (a + bi)^2 = a^2 + 2abi + (bi)^2 = a^2 + 2abi - b^2
        // z^2 = (a^2 - b^2) + (2ab)i
        //
        // So, z_next = (a^2 - b^2) + (2ab)i + (initialReal + i * initialImaginary)
        // The new real part (nextReal) = (a^2 - b^2) + initialReal
        // The new imaginary part (nextImaginary) = (2ab) + initialImaginary

        // Calculate the next values for 'z' based on the formula.
        double nextReal = currentReal * currentReal - currentImaginary * currentImaginary + initialReal;
        double nextImaginary = 2 * currentReal * currentImaginary + initialImaginary;

        // Update our current 'z' values for the next iteration.
        this.currentReal = nextReal;
        this.currentImaginary = nextImaginary;

        // Make the recursive call:
        // We pass the updated 'z' values and increment the iteration count.
        // The result of this call will be the final iteration count.
        return mandelbrotRecursive(initialReal, initialImaginary, iterationCount + 1);
    }

    // Helper function to convert iteration count to a color.
    // This determines the visual appearance of the fractal.
    private Color getColor(int iterations) {
        if (iterations == MAX_ITERATIONS) {
            // Points that reached MAX_ITERATIONS are considered to be *in* the Mandelbrot set.
            // They are conventionally colored black.
            return Color.BLACK;
        } else {
            // Points that escaped *before* reaching MAX_ITERATIONS are outside the set.
            // Their color is determined by how quickly they escaped.
            // This creates the beautiful, complex patterns surrounding the main set.
            // We use the HSB color model (Hue, Saturation, Brightness) for a smooth gradient.
            // 'Hue' cycles through colors (0.0 to 1.0). We map the iteration count to hue.
            // 'Saturation' and 'Brightness' are kept high for vibrant colors.
            float hue = (float) iterations / MAX_ITERATIONS;
            float saturation = 1.0f;
            float brightness = 1.0f;
            return Color.getHSBColor(hue, saturation, brightness);
        }
    }

    // This method is automatically called by Swing when the component needs to be painted.
    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g); // Always call the superclass method first.
        // Draw our generated fractal image onto the screen.
        // (0, 0) is the top-left corner of the drawing area.
        g.drawImage(fractalImage, 0, 0, this);
    }

    // Main method: The entry point of our Java application.
    public static void main(String[] args) {
        // Swing applications should have their GUI creation and updates
        // run on the Event Dispatch Thread (EDT). SwingUtilities.invokeLater()
        // ensures this happens. This is a crucial best practice for Swing.
        SwingUtilities.invokeLater(() -> {
            MandelbrotViewer viewer = new MandelbrotViewer(); // Create an instance of our viewer.
            viewer.setVisible(true); // Make the window visible on the screen.
        });
    }
}

// Example Usage:
// To run this code:
// 1. Ensure you have a Java Development Kit (JDK) installed.
// 2. Save this entire code block into a file named "MandelbrotViewer.java".
// 3. Open a terminal or command prompt.
// 4. Navigate to the directory where you saved the file.
// 5. Compile the code:
//    javac MandelbrotViewer.java
// 6. Run the compiled code:
//    java MandelbrotViewer
//
// A window titled "Mandelbrot Fractal Viewer" will appear, displaying the
// intricate Mandelbrot fractal.
//
// Key Concepts Learned:
// - Recursion: The `mandelbrotRecursive` method demonstrates recursion by calling itself.
//   - Base Case: The condition that stops the recursion (`if (currentReal * currentReal + currentImaginary * currentImaginary > 4.0 || iterationCount >= MAX_ITERATIONS)`).
//   - Recursive Step: The part where the function calls itself with updated values (`mandelbrotRecursive(initialReal, initialImaginary, iterationCount + 1)`).
// - Graphical Rendering: We use `BufferedImage` to create an in-memory image and then draw it onto the `Graphics` object provided by Swing's `paintComponent` method.
// - Mapping: We map screen pixel coordinates (x, y) to a corresponding point (real, imaginary) in the complex plane.
// - Iterative Process: Although implemented recursively, the underlying concept is an iterative application of a mathematical formula.
//
// For Further Exploration:
// - Zooming: Modify the `real` and `imaginary` mapping in `generateMandelbrot` to zoom into specific regions.
// - Color Schemes: Experiment with different ways to map `iterations` to colors in the `getColor` method.
// - Performance: Try implementing `mandelbrotRecursive` iteratively using a `while` loop to see the difference in performance and memory usage.
// - Anti-aliasing: Advanced techniques can smooth out the jagged edges of the fractal.
// - Other Fractals: Apply similar rendering techniques to generate other fractal patterns like the Julia Set.